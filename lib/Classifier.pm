package Classifier;
use Moose;
# ABSTRACT: a framework for classifying stuff

use Carp ();
use Classifier::Report;
use Classifier::ReportSet;
use List::MoreUtils ();
use Scalar::Util ();
use String::RewritePrefix;

=head1 SYNOPSIS

  my $classifier = Classifier->new({
    classifiers => [
      -EpicPoem
      -Film
      [ -TVSeries => { network => 'FOX' } ],
    ],
  });

  if (my $match = $classifier->consider('Terminator')) {
    say "It's a " . $match->type;  # Classifier::Film
  }

  my $analysis = $classifier->analyze('Terminator');

  for my $match ($analysis->matches) {
    say "It's a " . $match->type;  # first Classifier::Film
                                   # then  Classifier::TVSeries
  }

(Please note that when these documents were written, there was no known epic
poem named Terminator.)

=cut

override BUILDARGS => sub {
  my ($self, @args) = @_;
  my $args = super;

  if (my $c = $args->{classifiers}) {
    my $i = 0;
    $args->{_classifiers} = {};
    $args->{_classifiers}{ $i++ } = $self->_classifier_from_spec($_) for @$c;
  }

  return $args;
};

has _classifiers => (
  is  => 'ro',
  isa => 'HashRef[Classifier]',
  auto_deref => 1,
  default    => sub { {} },
);

sub _expand_class {
  my ($self, $class) = @_;

  String::RewritePrefix->rewrite(
    { '-' => $self->classifier_base_namespace . '::' },
    $class,
  );
}

sub _classifier_from_spec {
  my ($self, $c_spec) = @_;

  my @args;

  if (defined (my $reftype = Scalar::Util::reftype $c_spec)) {
    if (!Scalar::Util::blessed $c_spec and $reftype eq 'ARRAY') {
      # XXX: This will be richer in the future. -- rjbs, 2008-02-22
      Carp::confess("invalid classifier specification: [ @$c_spec ]")
        unless @$c_spec == 2;

      ($c_spec, @args) = @$c_spec;
    } else {
      Carp::confess("invalid classifier specification: $c_spec");
    }
  }

  my $c_class = $self->_expand_class($c_spec);
  return $c_class->new(@args);
}

=method classifiers

This method returns a list of all classifiers consulted by this classifier in
order to produce a report.

=cut

sub classifiers { values %{ $_[0]->_classifiers } }

=method classify

This is the method you probably want to call when using a classifier.  It
expects to receive one scalar as input and will either return a matching
Classifier::Report or nothing.

It returns only the first match, meaning that you should order your classifiers
properly if you plan to use this method.  To get a more complete analysis, use
the analyze method.

=cut

sub classify {
  my ($self, $input) = @_;

  for my $classifier ($self, $self->classifiers) {
    my $result = $classifier->consider($input);
    return $result if $result and $result->is_match;
  }

  return;
}

=method analyze

  my $report_set = $classifier->analyze($input);

This method returns a Classifier::ReportSet containing all reports generated by
all consulted classifiers.  Unlike the classify method, this will check all
classifiers even after one has matched.

=cut

sub analyze {
  my ($self, $input) = @_;

  my @reports;
  push @reports, $self->consider($input);

  for my $classifier ($self->classifiers) {
    push @reports, $classifier->analyze($input)->reports;
  }

  return Classifier::ReportSet->new(\@reports);
}

=method consider

  my $report_or_undef = $classifier->consider($input);

This is the method you probably want to implement for specific classification
subclasses most often.  It's meant to be handed a scalar as input and return
either nothing or a Classifier::Report object.

It will do this by calling the classifier's match, reject, or pass methods.

=cut

sub consider { return }

=method default_tags

This method should be implemented by subclasses, and should return a list of
tags that apply to any report generated by this classifier.  For example, if
a classifier is deciding whether input is a palindrome, it might have the tags
"palindrome" and "linguistic."

All reports and report sets can be queried for tags.

=cut

sub default_tags { return; }

=method default_type

This returns a string meant to identify what kind of report will be given for
this classifier.  By default, it will return the name of the classifier's
class.

=cut

sub default_type { (ref $_[0]) || $_[0] }

=method pass

This method is called by the classifier to signal that it is declining to offer
an opinion on the input.  Generally it would be used like this:

  sub consider {
    my ($self, $input) = @_;

    return $self->pass unless $input->isa('Email::Simple');

    ...
  }

=cut

sub pass { return; }

=method match

  return $self->match($details);

This method returns a matching report using the given details, which have no
universally defined semantics.

=method reject

  return $self->reject($details);

This method returns a rejecting report using the given details, which have no
universally defined semantics.

=cut

BEGIN {
  for my $method (qw(match reject)) {
    Sub::Install::install_sub({
      as   => $method,
      code => sub {
        my ($self, $details) = @_;

        my $meth = "new_$method";
        my $type = $self->default_type;

        return Classifier::Report->$meth({
          tags    => [ List::MoreUtils::uniq($type, $self->default_tags) ],
          type    => $type,
          details => $details,
        });
      }
    });
  }
}

=method classifier_base_namespace

This method returns the base namespace used to expand shorthand classifier
names used in construction.  The default value is Classifier.

=cut

sub classifier_base_namespace { 'Classifier' }

__PACKAGE__->meta->make_immutable;
no Moose;
1;
